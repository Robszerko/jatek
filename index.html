<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sz√≥Nyomoz√≥</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Roboto+Mono:wght@500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-gradient-start: #3d405b; --bg-gradient-end: #2c2f48; --container-bg: rgba(244, 241, 222, 0.95);
            --text-color: #3d405b; --title-color: #e07a5f; --border-color-idle: #bcaaa4;
            --border-color-active: #8d6e63; --correct-color: #81b29a; --present-color: #f2cc8f;
            --absent-color: #9e9e9e; --key-bg: '#dcd3b8'; --key-text: #3d405b;
            --key-shadow: 0 3px 0 #bcaaa4; --font-title: 'Fredoka One', cursive; --font-main: 'Roboto Mono', monospace;
            --difficulty-easy: #388e3c; --difficulty-hard: #f57c00; --difficulty-extra: #d32f2f;
        }
        body { background-color: var(--bg-gradient-end); background-image: radial-gradient(circle at top left, rgba(255, 255, 255, 0.1) 0%, transparent 40%), url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.08'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"); background-blend-mode: overlay; color: var(--text-color); font-family: var(--font-main); display: flex; justify-content: center; align-items: flex-start; padding: 15px; box-sizing: border-box; -webkit-user-select: none; user-select: none; touch-action: manipulation; transition: background 0.5s ease; position: relative; z-index: 1; }
        #game-container { background-color: var(--container-bg); border-radius: 20px; border: 2px solid rgba(255,255,255,0.2); box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 600px; padding: clamp(15px, 4vw, 30px); box-sizing: border-box; margin-top: 1vh; position: relative; }
        header, #word-tracker, #info-bar, #grid-container, #hint-controls, #keyboard-container, #rules-container { width: 100%; }
        header { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 0; margin-bottom: 20px; position: relative; }
        #header-main { display: flex; align-items: center; justify-content: center; position: relative; width: 100%; }
        #logo-container { display: flex; align-items: center; position: relative; }
        #logo-svg { width: clamp(80px, 20vw, 100px); height: auto; z-index: 1; }
        header h1 { font-family: var(--font-title); color: var(--title-color); font-size: clamp(2rem, 9vw, 3rem); margin: 0; letter-spacing: 0.05em; margin-left: -2px; z-index: 0; }
        #daily-score-display { font-family: var(--font-main); font-size: 1.1rem; font-weight: 700; color: var(--title-color); background: rgba(0,0,0,0.05); padding: 5px 15px; border-radius: 20px; border: 2px solid var(--border-color-idle); margin-top: 10px; }
        #word-tracker { display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        .tracker-item { flex: 1; min-width: 60px; padding: 10px 5px; text-align: center; border-radius: 8px; border: 2px solid var(--border-color-idle); font-weight: 500; cursor: pointer; transition: all 0.2s ease; position: relative; }
        .tracker-item.active { background-color: var(--title-color); color: white; border-color: var(--title-color); }
        .tracker-item.solved { background-color: var(--correct-color); border-color: var(--correct-color); color: white; cursor: not-allowed; }
        .tracker-item.failed { background-color: #e53935; border-color: #e53935; color: white; cursor: not-allowed; }
        #info-bar { padding: 12px; background: rgba(0,0,0,0.05); border: 2px solid var(--border-color-idle); border-radius: 10px; text-align: center; font-size: clamp(0.9rem, 2.5vw, 1rem); font-weight: 500; margin-bottom: 20px; display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; }
        #timer-display { font-weight: 700; font-size: 1.1em; color: var(--title-color); }
        #start-timer-button { background-color: var(--difficulty-easy); color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-weight: 700; transition: all 0.2s; font-size: 0.9rem; box-shadow: 0 3px 0 #2e7d32; }
        #start-timer-button:disabled { background-color: var(--absent-color); box-shadow: none; cursor: not-allowed; }
        #word-info-container { display: flex; flex-direction: column; align-items: center; }
        #difficulty-display { font-weight: 700; margin-top: 4px; border-radius: 10px; padding: 3px 10px; color: white; font-size: 0.9em; text-transform: uppercase; letter-spacing: 0.5px; text-shadow: 1px 1px 2px rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.3); }
        .difficulty-k√∂nny≈± { background-color: var(--difficulty-easy); } .difficulty-neh√©z { background-color: var(--difficulty-hard); } .difficulty-extra-neh√©z { background-color: var(--difficulty-extra); }
        #grid-container { display: grid; grid-template-rows: repeat(6, 1fr); gap: 8px; max-width: 500px; margin: 0 auto 20px auto; height: 360px; }
        .grid-row { display: grid; gap: 8px; }
        .grid-cell { perspective: 1000px; }
        .cell-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; }
        .grid-cell.flip .cell-inner { transform: rotateX(180deg); }
        .cell-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; -webkit-backface-visibility: hidden; display: flex; justify-content: center; align-items: center; font-size: clamp(1.5rem, 5vw, 2.2rem); font-weight: bold; text-transform: uppercase; box-sizing: border-box; border-radius: 8px; }
        .cell-front { border: 3px solid var(--border-color-idle); }
        .cell-revealed { border-color: var(--correct-color); background-color: rgba(129, 178, 154, 0.2); }
        .grid-cell.filled .cell-front:not(.cell-revealed) { border-color: var(--border-color-active); animation: pop 0.2s; }
        .cell-back { color: white; transform: rotateX(180deg); border: 3px solid transparent; }
        .cell-back.correct { background-color: var(--correct-color); border-color: var(--correct-color);} .cell-back.present { background-color: var(--present-color); border-color: var(--present-color);} .cell-back.absent  { background-color: var(--absent-color); border-color: var(--absent-color);}
        @keyframes pop { 50% { transform: scale(1.1); } }
        #hint-display-container { background-color: rgba(0,0,0,0.05); border: 2px solid var(--border-color-idle); border-radius: 10px; padding: 15px; margin-bottom: 15px; text-align: center; min-height: 40px; font-weight: 500; color: #5d4037; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 8px; }
        #hint-display-area p { margin: 0; font-style: italic; line-height: 1.5; } #hint-display-area p strong { color: var(--title-color); font-style: normal; }
        .hint-alert { color: var(--correct-color); font-weight: 900; font-style: normal; animation: flash 1s infinite; font-size: 1.8rem; letter-spacing: 2px; }
        @keyframes flash { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.3; transform: scale(1.05); } }
        #hint-controls { display: flex; justify-content: center; gap: 10px; margin-bottom: 25px; }
        .hint-button { color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; font-weight: 700; transition: all 0.2s; font-size: 0.9rem; flex-grow: 1; max-width: 200px; }
        .hint-button#request-text-hint-button { background-color: var(--present-color); box-shadow: 0 3px 0 #d0a457; }
        .hint-button#request-letter-hint-button { background-color: var(--correct-color); box-shadow: 0 3px 0 #6a9982; }
        .hint-button:hover:not(:disabled) { transform: translateY(-2px); }
        .hint-button:disabled { background-color: var(--absent-color); cursor: not-allowed; box-shadow: none; opacity: 0.7; }
        #keyboard-container { display: flex; flex-direction: column; gap: 12px; }
        #keyboard-container.disabled { pointer-events: none; opacity: 0.6; }
        .keyboard-row { display: flex; justify-content: center; gap: 6px; }
        .key { font-family: var(--font-main); font-weight: 500; background-color: var(--key-bg); color: var(--key-text); border: none; border-radius: 8px; height: 60px; flex: 1; cursor: pointer; text-transform: uppercase; font-size: clamp(1rem, 3vw, 1.4rem); display: flex; justify-content: center; align-items: center; transition: all 0.1s ease-in-out; box-shadow: var(--key-shadow); }
        .key:active, .key.active-press { transform: translateY(2px); box-shadow: none; }
        .key.large { flex: 1.5; font-size: 0.9rem; }
        .key.correct, .key.correct:hover { background-color: var(--correct-color); color: white; } .key.present, .key.present:hover { background-color: var(--present-color); color: white; } .key.absent, .key.absent:hover { background-color: var(--absent-color); color: white; opacity: 0.7; }
        #rules-container { margin-top: 30px; padding-top: 20px; border-top: 2px solid var(--border-color-idle); color: var(--text-color); font-size: clamp(0.8rem, 2.2vw, 0.9rem); line-height: 1.7; }
        #rules-container h3 { font-family: var(--font-title); color: var(--title-color); text-align: center; font-size: 1.5rem; margin: 0 0 15px 0; }
        #rules-container ul { list-style-type: 'üïµÔ∏è '; padding-left: 20px; text-align: left; margin: 0; }
        #rules-container li { margin-bottom: 12px; padding-left: 8px; }
        .rules-correct { color: var(--correct-color); font-weight: 700; } .rules-present { color: var(--present-color); font-weight: 700; } .rules-absent { color: var(--absent-color); font-weight: 700; } .rules-penalty { color: #d32f2f; font-weight: 700; }
        #unlock-bonus-button { background-color: var(--difficulty-extra); color: white; border: 2px solid white; border-radius: 10px; padding: 15px 30px; font-family: var(--font-title); font-size: 1.2rem; letter-spacing: 1px; cursor: pointer; margin: 10px 0 20px 0; text-shadow: 1px 1px 3px rgba(0,0,0,0.4); }
        #unlock-bonus-button.pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7); } 70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(211, 47, 47, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(211, 47, 47, 0); } }
        
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s; }
        .overlay.visible { opacity: 1; visibility: visible; transition-delay: 0s; }
        .overlay-content { background-color: var(--container-bg); color: var(--text-color); padding: clamp(20px, 4vw, 30px); border-radius: 20px; text-align: center; box-shadow: 0 5px 25px rgba(0,0,0,0.3); max-width: 95vw; width: auto; max-height: 95vh; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .overlay-content h2 { font-family: var(--font-title); color: var(--title-color); margin: 0 0 10px 0; font-size: clamp(1.5rem, 6vw, 2.2rem); }
        #refresh-button, #close-wheel-button { background-color: var(--title-color); color: white; border: none; padding: 12px 25px; border-radius: 8px; font-family: var(--font-main); font-weight: 700; font-size: 1rem; cursor: pointer; margin-top: 15px; transition: transform 0.2s ease; }

        #wheel-game-container { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        #wheel-wrapper { position: relative; width: 300px; height: 300px; margin: 20px auto; }
        #wheel-pointer { width: 0; height: 0; border-left: 20px solid transparent; border-right: 20px solid transparent; border-top: 40px solid #e53935; position: absolute; top: -15px; left: 50%; transform: translateX(-50%); z-index: 10; }
        #wheel { width: 100%; height: 100%; transition: transform 4s cubic-bezier(0.25, 0.1, 0.25, 1); }
        #wheel-game-ui { display: flex; flex-direction: column; align-items: center; gap: 15px; width: 100%; }
        #puzzle-category { font-size: 1.2rem; font-weight: bold; background: var(--title-color); color: white; padding: 5px 15px; border-radius: 10px; }
        #puzzle-board { display: flex; flex-wrap: wrap; justify-content: center; gap: 5px; max-width: 800px; padding: 10px; }
        .puzzle-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .puzzle-tile { width: 35px; height: 45px; background-color: var(--correct-color); color: white; border: 2px solid #fff; border-radius: 5px; perspective: 1000px; }
        .puzzle-tile.space { background-color: transparent; border: none; }
        .tile-inner { position: relative; width: 100%; height: 100%; transition: transform 0.6s; transform-style: preserve-3d; }
        .puzzle-tile.revealed .tile-inner { transform: rotateY(180deg); }
        .tile-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; }
        .tile-front { background-color: var(--correct-color); }
        .tile-back { background-color: #fff; color: var(--text-color); font-weight: bold; font-size: 1.5rem; transform: rotateY(180deg); }
        #player-info { font-size: 1.5rem; font-weight: bold; }
        #wheel-controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        #wheel-controls button { padding: 10px 15px; font-size: 1rem; }
        #power-meter-container { width: 80%; max-width: 400px; height: 20px; background-color: #ccc; border-radius: 10px; overflow: hidden; margin-top: 10px; cursor: pointer; border: 2px solid #5d4037; }
        #power-meter-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #f2cc8f, #e07a5f, #d32f2f); }
        .power-up { animation: power-up 1.5s linear infinite; }
        @keyframes power-up { 0% { width: 0%; } 50% { width: 100%; } 100% { width: 0%; } }
    </style>
</head>
<body>
    <div id="game-container">
        <header>
            <div id="header-main">
                <div id="logo-container">
                    <svg id="logo-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" style="stop-color: var(--title-color);stop-opacity:1" /><stop offset="100%" style="stop-color: var(--text-color);stop-opacity:1" /></linearGradient></defs><circle cx="50" cy="50" r="40" stroke="url(#grad1)" stroke-width="12" fill="#ffffff"/><line x1="32" y1="72" x2="5" y2="95" stroke="url(#grad1)" stroke-width="16" stroke-linecap="round"/><text x="50" y="62" font-family="Fredoka One, sans-serif" font-size="38" fill="var(--text-color)" text-anchor="middle">Sz√≥</text></svg>
                    <h1>Nyomoz√≥</h1>
                </div>
            </div>
            <div id="daily-score-display">Mai pontsz√°m: <span>0</span></div>
        </header>
        
        <div id="word-tracker"></div>
        <button id="unlock-bonus-button">üèÜ Szerencseker√©k üèÜ</button>
        
        <div id="info-bar">
            <div id="word-info-container">
                <span id="word-info"></span>
                <span id="difficulty-display"></span> 
            </div>
            <span id="timer-display">03:00</span>
            <button id="start-timer-button">√ìra ind√≠t√°sa</button>
        </div>
        <main id="grid-container"></main>
        
        <div id="hint-display-container">
             <div id="hint-display-area"></div>
             <div id="game-end-message"></div>
        </div>
        <div id="hint-controls">
            <button id="request-text-hint-button" class="hint-button">Sz√∂veges seg√≠ts√©g</button>
            <button id="request-letter-hint-button" class="hint-button">Bet≈± felfed√©se</button>
        </div>
        
        <div id="keyboard-container"></div>
        
        <div id="rules-container">
            <h3>J√°t√©kszab√°lyok</h3>
            <ul>
                <li><strong>Pontgy≈±jt√©s:</strong> Oldd meg a szavakat √©s gy≈±jts pontokat! A pontsz√°mod √©jf√©lkor null√°z√≥dik.</li>
                <li><strong>Alapj√°t√©k:</strong> 5 sz√≥ √≥r√°nk√©nt, 3 perced van szavank√©nt. A megfejtett sz√≥√©rt a hossza alapj√°n kapsz pontot.</li>
                <li><strong>Seg√≠ts√©gek:</strong> A seg√≠ts√©gk√©r√©s <span class="rules-penalty">pontokba ker√ºl</span> a sz√≥ neh√©zs√©ge alapj√°n. A j√°t√©k r√°k√©rdez a v√°s√°rl√°s el≈ëtt.</li>
                <li><strong>Szerencseker√©k:</strong> Ha mind az 5 sz√≥t hib√°tlanul megfejted, egy <strong>Szerencseker√©k</strong> b√≥nusz j√°t√©k oldhat√≥ fel, ahol tov√°bbi pontokat szerezhetsz!</li>
            </ul>
        </div>
    </div>

    <div id="new-set-overlay" class="overlay">
        <div class="overlay-content">
            <h2>√öj Feladv√°nyok!</h2>
            <p>√öj √≥ra kezd≈ëd√∂tt, friss szavak v√°rnak r√°d.</p>
            <button id="refresh-button">Friss√≠t√©s</button>
        </div>
    </div>
    
    <div id="wheel-game-overlay" class="overlay">
        <div class="overlay-content">
            <div id="wheel-game-container">
                <h2>Szerencseker√©k</h2>
                <div id="wheel-game-ui">
                    <div id="player-info">K√∂r pontsz√°ma: <span id="player-score">0</span></div>
                    <div id="puzzle-category"></div>
                    <div id="puzzle-board"></div>
                    <div id="wheel-wrapper">
                        <div id="wheel-pointer"></div>
                        <svg id="wheel" viewBox="0 0 100 100"></svg>
                    </div>
                    <div id="power-meter-container" title="Kattints a p√∂rget√©shez, majd a megfelel≈ë er≈ëss√©gn√©l √∫jra a meg√°ll√≠t√°shoz!">
                        <div id="power-meter-bar"></div>
                    </div>
                    <div id="wheel-controls">
                        <button id="spin-button" class="hint-button">P√∂rget√©s</button>
                        <button id="buy-vowel-button" class="hint-button" disabled>Mag√°nhangz√≥ (250)</button>
                        <button id="solve-button" class="hint-button" disabled>Megfejtem</button>
                    </div>
                </div>
                <button id="close-wheel-button" style="display: none;">Bez√°r√°s</button>
            </div>
        </div>
    </div>

    <script src="szavak.js"></script>
    <script src="szerencsekerek_feladvanyok.js"></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const MAX_GUESSES = 6; let gameData = {}; let timerInterval;
        const gridContainer = document.getElementById('grid-container'); const keyboardContainer = document.getElementById('keyboard-container'); const hintDisplayArea = document.getElementById('hint-display-area'); const gameEndMessageEl = document.getElementById('game-end-message'); const requestTextHintButton = document.getElementById('request-text-hint-button'); const requestLetterHintButton = document.getElementById('request-letter-hint-button'); const wordTrackerContainer = document.getElementById('word-tracker'); const timerDisplay = document.getElementById('timer-display'); const startTimerButton = document.getElementById('start-timer-button'); const unlockBonusButton = document.getElementById('unlock-bonus-button'); const dailyScoreDisplaySpan = document.querySelector('#daily-score-display span'); const newSetOverlay = document.getElementById('new-set-overlay'); const refreshButton = document.getElementById('refresh-button');
        const wheelGameOverlay = document.getElementById('wheel-game-overlay'); const closeWheelButton = document.getElementById('close-wheel-button'); const wheel = document.getElementById('wheel'); const spinButton = document.getElementById('spin-button'); const powerMeterBar = document.getElementById('power-meter-bar'); const powerMeterContainer = document.getElementById('power-meter-container'); const playerScoreEl = document.getElementById('player-score'); const puzzleBoardEl = document.getElementById('puzzle-board'); const puzzleCategoryEl = document.getElementById('puzzle-category'); const buyVowelButton = document.getElementById('buy-vowel-button'); const solveButton = document.getElementById('solve-button'); const wordInfoDisplay = document.getElementById('word-info'); const difficultyDisplay = document.getElementById('difficulty-display');

        const KEY_LAYOUT = [ ['Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I', 'O', 'P', '√ñ', '√ú', '√ì'], ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', '√â', '√Å', '≈∞', '≈ê', '√ö'], ['Enter', 'Y', 'X', 'C', 'V', 'B', 'N', 'M', '√ç', 'Backspace'] ];
        const wheelSegments = [ { label: '1000', value: 1000, color: '#f2cc8f' }, { label: 'CS≈êD', value: 'bankrupt', color: '#e53935' }, { label: '500', value: 500, color: '#a5d6a7' }, { label: '1500', value: 1500, color: '#81b29a' }, { label: '750', value: 750, color: '#b39ddb' }, { label: 'DUPLA', value: 'double', color: '#ffd54f' }, { label: '250', value: 250, color: '#a5d6a7' }, { label: '2000', value: 2000, color: '#e07a5f' }, { label: '1250', value: 1250, color: '#b39ddb' }, { label: 'CS≈êD', value: 'bankrupt', color: '#e53935' }, { label: '500', value: 500, color: '#f2cc8f' }, { label: '1750', value: 1750, color: '#81b29a' } ];
        let wheelState = { puzzle: {}, score: 0, isSpinning: false, guessedLetters: [] };
        const VOWELS = "A√ÅE√âI√çO√ì√ñ≈êU√ö√ú≈∞"; const CONSONANTS = "BCDFGHJKLMNPQRSTVXYZ";

        function createWheel() { const numSegments = wheelSegments.length; const angleStep = 360 / numSegments; const radius = 50; for (let i = 0; i < numSegments; i++) { const segment = wheelSegments[i]; const startAngle = i * angleStep; const endAngle = (i + 1) * angleStep; const start = polarToCartesian(radius, radius, radius, endAngle); const end = polarToCartesian(radius, radius, radius, startAngle); const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1"; const d = `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${end.x} ${end.y} L ${radius} ${radius} Z`; const path = document.createElementNS("http://www.w3.org/2000/svg", "path"); path.setAttribute("d", d); path.setAttribute("fill", segment.color); wheel.appendChild(path); const textAngle = startAngle + angleStep / 2; const textPos = polarToCartesian(radius, radius, radius * 0.7, textAngle); const text = document.createElementNS("http://www.w3.org/2000/svg", "text"); text.setAttribute("x", textPos.x); text.setAttribute("y", textPos.y); text.setAttribute("text-anchor", "middle"); text.setAttribute("dominant-baseline", "middle"); text.setAttribute("font-size", "8"); text.setAttribute("font-weight", "bold"); text.setAttribute("transform", `rotate(${textAngle + 90} ${textPos.x} ${textPos.y})`); text.textContent = segment.label; wheel.appendChild(text); } }
        function polarToCartesian(cx, cy, r, angle) { const rad = (angle - 90) * Math.PI / 180.0; return { x: cx + (r * Math.cos(rad)), y: cy + (r * Math.sin(rad)) }; }
        function initWheelGame() { gameData.bonusPlayed = true; saveGame(); unlockBonusButton.disabled = true; unlockBonusButton.classList.remove('pulse'); wheelState = { puzzle: {}, score: 0, spinResult: null, isSpinning: false, guessedLetters: [] }; const puzzleIndex = Math.floor(Math.random() * wheelPuzzles.length); wheelState.puzzle = wheelPuzzles[puzzleIndex]; updateWheelPlayerScore(0, true); setupPuzzleBoard(); updateUIForGameState('start'); wheelGameOverlay.classList.add('visible'); }
        function setupPuzzleBoard() { puzzleBoardEl.innerHTML = ''; puzzleCategoryEl.textContent = wheelState.puzzle.category; const words = wheelState.puzzle.puzzle.split(' '); words.forEach(word => { const row = document.createElement('div'); row.className = 'puzzle-row'; word.split('').forEach(char => { const tile = document.createElement('div'); if (char === ' ') { tile.className = 'puzzle-tile space'; } else { tile.className = 'puzzle-tile'; tile.innerHTML = `<div class="tile-inner"><div class="tile-face tile-front"></div><div class="tile-face tile-back">${char}</div></div>`; tile.dataset.letter = char.toUpperCase(); } row.appendChild(tile); }); puzzleBoardEl.appendChild(row); }); }
        function handleSpinClick() { if (wheelState.isSpinning) return; powerMeterBar.classList.add('power-up'); powerMeterContainer.onclick = () => { const power = powerMeterBar.offsetWidth / powerMeterContainer.offsetWidth; powerMeterBar.classList.remove('power-up'); powerMeterContainer.onclick = null; spinWheel(power); }; }
        function spinWheel(power) { wheelState.isSpinning = true; updateUIForGameState('spinning'); const baseRotations = 3; const randomExtra = Math.random(); const powerRotation = 2 * power; const totalRotation = (baseRotations + randomExtra + powerRotation) * 360; const currentRotation = parseFloat(wheel.dataset.rotation || 0); const newRotation = currentRotation + totalRotation; wheel.style.transform = `rotate(${newRotation}deg)`; wheel.dataset.rotation = newRotation; setTimeout(() => { const finalAngle = newRotation % 360; const segmentAngle = 360 / wheelSegments.length; const segmentIndex = Math.floor((360 - finalAngle % 360) / segmentAngle) % wheelSegments.length; handleSpinResult(wheelSegments[segmentIndex].value); }, 4000); }
        function handleSpinResult(result) { wheelState.isSpinning = false; if (result === 'bankrupt') { alert("CS≈êD! Elvesztetted a k√∂rben gy≈±jt√∂tt pontjaidat."); updateWheelPlayerScore(0, true); updateUIForGameState('start'); } else { wheelState.spinResult = result; updateUIForGameState('guess_consonant'); } }
        function guessLetter(letter) { letter = letter.toUpperCase(); if (wheelState.guessedLetters.includes(letter)) { alert("Ezt a bet≈±t m√°r k√©rted!"); return; } if (VOWELS.includes(letter)) { if (wheelState.score < 250) { alert("Nincs el√©g pontod mag√°nhangz√≥t venni!"); return; } updateWheelPlayerScore(-250); } wheelState.guessedLetters.push(letter); let foundCount = 0; document.querySelectorAll(`.puzzle-tile[data-letter="${letter}"]`).forEach(tile => { tile.classList.add('revealed'); foundCount++; }); if (foundCount > 0) { if (CONSONANTS.includes(letter)) { let multiplier = (wheelState.spinResult === 'double') ? 2 : 1; let basePoints = (wheelState.spinResult === 'double') ? 1000 : wheelState.spinResult; let pointsEarned = foundCount * basePoints * multiplier; updateWheelPlayerScore(pointsEarned); } } else { alert(`Sajnos a(z) "${letter}" bet≈± nem szerepel a feladv√°nyban.`); } updateUIForGameState('start'); checkWheelWin(); }
        function solve() { const solution = prompt("K√©rlek, add meg a teljes megfejt√©st:"); if (solution && solution.toUpperCase().trim() === wheelState.puzzle.puzzle.toUpperCase()) { alert(`Helyes megfejt√©s! Nyert√©l ${wheelState.score} pontot!`); addPointsToDailyScore(wheelState.score); document.querySelectorAll('.puzzle-tile[data-letter]').forEach(tile => tile.classList.add('revealed')); updateUIForGameState('game_over'); } else { alert("Sajnos ez nem a helyes megfejt√©s. A k√∂rben szerzett pontjaidat elvesztetted!"); updateWheelPlayerScore(0, true); updateUIForGameState('start'); } }
        function updateWheelPlayerScore(amount, absolute = false) { if (absolute) { wheelState.score = amount; } else { wheelState.score += amount; } playerScoreEl.textContent = wheelState.score; }
        function updateUIForGameState(state) { spinButton.disabled = true; buyVowelButton.disabled = true; solveButton.disabled = true; if (state === 'start') { spinButton.disabled = false; if (wheelState.score >= 250) buyVowelButton.disabled = false; solveButton.disabled = false; } else if (state === 'spinning') { } else if (state === 'guess_consonant') { const letter = prompt(`P√∂rget√©s: ${wheelState.spinResult === 'double' ? 'DUPLA' : wheelState.spinResult}\nMelyik m√°ssalhangz√≥t k√©red?`); if (letter && CONSONANTS.includes(letter.toUpperCase())) { guessLetter(letter); } else { alert("√ârv√©nytelen m√°ssalhangz√≥. √öjra p√∂rgethetsz."); updateUIForGameState('start'); } } else if (state === 'game_over') { closeWheelButton.style.display = 'block'; } }
        function checkWheelWin() { const allTiles = document.querySelectorAll('.puzzle-tile[data-letter]'); const revealedTiles = document.querySelectorAll('.puzzle-tile.revealed[data-letter]'); if(allTiles.length === revealedTiles.length) { alert(`Gratul√°lunk, megfejtetted! Nyert√©l ${wheelState.score} pontot!`); addPointsToDailyScore(wheelState.score); updateUIForGameState('game_over'); } }
        
        function checkDailyReset() { const today = new Date().toDateString(); let stats = JSON.parse(localStorage.getItem('szonyomozo_daily_stats')); if (!stats || stats.lastResetDate !== today) { stats = { totalScore: 0, lastResetDate: today }; localStorage.setItem('szonyomozo_daily_stats', JSON.stringify(stats)); } updateDailyScoreDisplay(stats.totalScore); }
        function getDailyScore() { const stats = JSON.parse(localStorage.getItem('szonyomozo_daily_stats')); return stats ? stats.totalScore : 0; }
        function addPointsToDailyScore(points) { let stats = JSON.parse(localStorage.getItem('szonyomozo_daily_stats')); stats.totalScore += points; localStorage.setItem('szonyomozo_daily_stats', JSON.stringify(stats)); updateDailyScoreDisplay(stats.totalScore); }
        function updateDailyScoreDisplay(score) { dailyScoreDisplaySpan.textContent = score; }

        function initGame() {
            checkDailyReset();
            const hourSeed = getCurrentHourSeed(); const storedData = JSON.parse(localStorage.getItem('szonyomozo_progress'));
            if (storedData && storedData.seed === hourSeed) { gameData = storedData; } 
            else {
                gameData = { seed: hourSeed, hourlySet: [], progress: [], timers: [], revealedIndices: {}, isTimerRunning: [], revealedHints: {}, bonusPlayed: false, currentWordIndex: 0, currentRow: 0, currentCol: 0, isGameOver: false };
                let tempWordIndices = Array.from(Array(wordData.length).keys());
                for (let i = 0; i < 5; i++) { const randomIndex = Math.floor(seededRandom(hourSeed + i * 13) * tempWordIndices.length); gameData.hourlySet.push(tempWordIndices.splice(randomIndex, 1)[0]); }
                gameData.progress = Array(5).fill(null).map(() => ({status: 'pending', scored: false}));
                gameData.timers = Array(5).fill(180);
                gameData.isTimerRunning = Array(5).fill(false);
                for(let i=0; i<5; i++) { gameData.revealedIndices[i] = []; gameData.revealedHints[i] = { text: [], textUsedCount: 0 }; }
                gameData.currentWordIndex = 0;
            }
            renderWordTracker(); loadWord(gameData.currentWordIndex); checkForBonusGameUnlock();
        }
        function loadWord(indexInSet) {
            clearInterval(timerInterval); gameData.currentWordIndex = indexInSet;
            const wordProgress = gameData.progress[indexInSet].status;
            gameData.isGameOver = (wordProgress !== 'pending');
            gameData.currentRow = 0; gameData.currentCol = 0;
            const wordObject = wordData[gameData.hourlySet[indexInSet]];
            const { word, category, difficulty } = wordObject;
            wordInfoDisplay.textContent = `${category} | ${word.length} bet≈±s`;
            difficultyDisplay.className = 'difficulty-display';
            difficultyDisplay.classList.add(`difficulty-${difficulty.toLowerCase().replace(' ', '-')}`);
            difficultyDisplay.textContent = difficulty;
            updateTimerDisplay(gameData.timers[indexInSet]);
            hintDisplayArea.innerHTML = ''; gameEndMessageEl.innerHTML = '';
            renderAllRevealedHints(); initializeGrid(word.length); initializeKeyboard(); renderWordTracker();
            
            if (gameData.isGameOver) {
                requestTextHintButton.disabled = true; requestLetterHintButton.disabled = true;
                startTimerButton.style.display = 'none';
                keyboardContainer.classList.add('disabled');
                showEndMessage();
            } else {
                requestTextHintButton.disabled = true;
                requestLetterHintButton.disabled = true;
                keyboardContainer.classList.add('disabled');
                startTimerButton.style.display = 'inline-block';
                startTimerButton.disabled = gameData.isTimerRunning[indexInSet];
                if (gameData.isTimerRunning[indexInSet]) {
                     startTimer(gameData.timers[indexInSet]);
                     handleStartTimerClick();
                }
            }
            updateTextHintButtonLabel();
        }
        function submitGuess() {
            const wordObject = wordData[gameData.hourlySet[gameData.currentWordIndex]];
            if (gameData.currentCol !== wordObject.word.length) return;
            const guess = Array.from(document.getElementById(`row-${gameData.currentRow}`).children).map(cell => cell.querySelector('.cell-front').textContent).join('');
            if (guess.length !== wordObject.word.length) return; // Ne engedje a bek√ºld√©st, ha a sor nem teljes
            
            flipRow(guess, wordObject.word.toUpperCase()); 
            
            if (guess === wordObject.word.toUpperCase()) {
                if(!gameData.progress[gameData.currentWordIndex].scored) {
                    const points = wordObject.word.length * 100; addPointsToDailyScore(points); gameEndMessageEl.innerHTML = `Helyes! +${points} pont!`; gameData.progress[gameData.currentWordIndex].scored = true;
                }
                gameData.progress[gameData.currentWordIndex].status = 'solved';
                clearInterval(timerInterval); gameData.isGameOver = true;
                keyboardContainer.classList.add('disabled');
                requestTextHintButton.disabled = true; requestLetterHintButton.disabled = true;
                setTimeout(() => { showEndMessage(); checkForBonusGameUnlock(); saveGame(); renderWordTracker(); }, 2000);
            } else {
                gameData.currentRow++; 
                if (gameData.currentRow >= MAX_GUESSES) { 
                    clearInterval(timerInterval); failWord(); 
                } else { 
                    gameData.currentCol = 0; 
                }
            }
            saveGame();
        }
        function handleHintCost() { const wordObject = wordData[gameData.hourlySet[gameData.currentWordIndex]]; switch (wordObject.difficulty) { case "K√∂nny≈±": return 50; case "Neh√©z": return 75; case "Extra Neh√©z": return 100; default: return 50; } }
        function spendPointsForHint(cost) { const currentScore = getDailyScore(); if (currentScore < cost) { alert(`Nincs el√©g pontod! A seg√≠ts√©g ${cost} pontba ker√ºl, de neked csak ${currentScore} pontod van.`); return false; } if (confirm(`Biztosan elk√∂ltesz ${cost} pontot a seg√≠ts√©g√©rt?`)) { addPointsToDailyScore(-cost); return true; } return false; }
        
        function saveGame() { localStorage.setItem('szonyomozo_progress', JSON.stringify(gameData)); }
        function renderWordTracker() { wordTrackerContainer.innerHTML = ''; gameData.hourlySet.forEach((_, index) => { const item = document.createElement('div'); item.className = 'tracker-item'; item.textContent = `${index + 1}. sz√≥`; item.dataset.index = index; const status = gameData.progress[index].status; if (status === 'solved') item.classList.add('solved'); if (status === 'failed') item.classList.add('failed'); if (index === gameData.currentWordIndex) item.classList.add('active'); if (status === 'pending') { item.addEventListener('click', () => { if(index !== gameData.currentWordIndex && !gameData.isTimerRunning[index]) loadWord(index); }); } wordTrackerContainer.appendChild(item); }); }
        function updateTimerDisplay(timeLeft) { if (timeLeft < 0) timeLeft = 0; const minutes = Math.floor(timeLeft / 60).toString().padStart(2, '0'); const seconds = (timeLeft % 60).toString().padStart(2, '0'); timerDisplay.textContent = `${minutes}:${seconds}`; }
        function startTimer(duration) { clearInterval(timerInterval); let timeLeft = duration; updateTimerDisplay(timeLeft); timerInterval = setInterval(() => { if (gameData.isGameOver) { clearInterval(timerInterval); return; } timeLeft--; gameData.timers[gameData.currentWordIndex] = timeLeft; updateTimerDisplay(timeLeft); if (timeLeft <= 0) { clearInterval(timerInterval); failWord(); } }, 1000); }
        function showHintAlert(callback) { gameEndMessageEl.innerHTML = `<strong class="hint-alert">SEG√çTS√âG!</strong>`; setTimeout(() => { if (gameData.isGameOver) { showEndMessage(); return; } gameEndMessageEl.innerHTML = ''; callback(); }, 2000); }
        function revealTextHint(hintIndex) { const hintsData = gameData.revealedHints[gameData.currentWordIndex]; if (hintsData.text.includes(hintIndex)) return; hintsData.text.push(hintIndex); hintsData.textUsedCount++; updateTextHintButtonLabel(); if (hintsData.textUsedCount >= 3) { requestTextHintButton.disabled = true; } const wordObject = wordData[gameData.hourlySet[gameData.currentWordIndex]]; if (wordObject.hints && wordObject.hints[hintIndex]) { const p = document.createElement('p'); p.innerHTML = `<strong>${hintIndex + 1}. seg√≠ts√©g:</strong> ${wordObject.hints[hintIndex]}`; p.dataset.hintId = hintIndex; hintDisplayArea.appendChild(p); } saveGame(); }
        function revealRandomLetter() { if (gameData.isGameOver) return; const wordObject = wordData[gameData.hourlySet[gameData.currentWordIndex]]; const targetWord = wordObject.word.toUpperCase(); const revealedIndices = gameData.revealedIndices[gameData.currentWordIndex]; const unrevealedWordIndices = []; for (let i = 0; i < targetWord.length; i++) { if (!revealedIndices.includes(i)) unrevealedWordIndices.push(i); } if (unrevealedWordIndices.length === 0) { requestLetterHintButton.disabled = true; return; } const indexToReveal = unrevealedWordIndices[Math.floor(Math.random() * unrevealedWordIndices.length)]; revealedIndices.push(indexToReveal); const letter = targetWord[indexToReveal]; for(let i=0; i<MAX_GUESSES; i++) { const cellFront = document.querySelector(`#row-${i} #cell-container-${i}-${indexToReveal} .cell-front`); if(cellFront) { cellFront.textContent = letter; cellFront.classList.add('cell-revealed'); } } updateKeyboard(letter, 'correct'); if (unrevealedWordIndices.length - 1 === 0) { requestLetterHintButton.disabled = true; } saveGame(); }
        function failWord() { gameData.isGameOver = true; gameData.progress[gameData.currentWordIndex].status = 'failed'; requestTextHintButton.disabled = true; requestLetterHintButton.disabled = true; keyboardContainer.classList.add('disabled'); showEndMessage(); saveGame(); renderWordTracker(); checkForBonusGameUnlock(); }
        function initializeGrid(wordLength) { gridContainer.innerHTML = ''; for (let i = 0; i < MAX_GUESSES; i++) { const row = document.createElement('div'); row.className = 'grid-row'; row.id = `row-${i}`; row.style.gridTemplateColumns = `repeat(${wordLength}, 1fr)`; for (let j = 0; j < wordLength; j++) { row.innerHTML += `<div class="grid-cell" id="cell-container-${i}-${j}"><div class="cell-inner"><div class="cell-face cell-front"></div><div class="cell-face cell-back"></div></div></div>`; } gridContainer.appendChild(row); } const revealed = gameData.revealedIndices[gameData.currentWordIndex]; if (revealed && revealed.length > 0) { const targetWord = wordData[gameData.hourlySet[gameData.currentWordIndex]].word.toUpperCase(); revealed.forEach(index => { for(let i=0; i<MAX_GUESSES; i++) { const cellFront = document.querySelector(`#row-${i} #cell-container-${i}-${index} .cell-front`); if(cellFront) { cellFront.textContent = targetWord[index]; cellFront.classList.add('cell-revealed'); } } }); } }
        function initializeKeyboard() { keyboardContainer.innerHTML = ''; KEY_LAYOUT.forEach(rowKeys => { const row = document.createElement('div'); row.className = 'keyboard-row'; rowKeys.forEach(key => { const button = document.createElement('button'); button.textContent = key; button.className = 'key'; button.dataset.key = key.toUpperCase(); if (key === 'Enter' || key === 'Backspace') button.classList.add('large'); button.addEventListener('click', () => handleKeyPress(key)); row.appendChild(button); }); keyboardContainer.appendChild(row); }); }
        function handleKeyPress(key) { if (gameData.isGameOver || wheelGameOverlay.classList.contains('visible') || keyboardContainer.classList.contains('disabled')) return; const upperKey = key.toUpperCase(); if (upperKey === 'ENTER') submitGuess(); else if (upperKey === 'BACKSPACE' || upperKey === 'DELETE') deleteLetter(); else if (upperKey.length === 1 && "QWERTZUIOP√ñ√ú√ìASDFGHJKL√â√Å≈∞≈ê√öYXCVBNM√ç".includes(upperKey)) addLetter(upperKey); }
        function addLetter(letter) { const wordLength = wordData[gameData.hourlySet[gameData.currentWordIndex]].word.length; if (gameData.currentCol >= wordLength) return; const cell = document.querySelector(`#row-${gameData.currentRow}`).children[gameData.currentCol]; if (cell.querySelector('.cell-front').classList.contains('cell-revealed')) { gameData.currentCol++; if (gameData.currentCol < wordLength) addLetter(letter); else gameData.currentCol = wordLength; return; } if (cell) { cell.querySelector('.cell-front').textContent = letter; cell.classList.add('filled'); gameData.currentCol++; } }
        function deleteLetter() { if (gameData.currentCol <= 0) return; gameData.currentCol--; const cell = document.querySelector(`#row-${gameData.currentRow}`).children[gameData.currentCol]; if (cell.querySelector('.cell-front').classList.contains('cell-revealed')) { if(gameData.currentCol > 0) deleteLetter(); return; } if (cell) { cell.querySelector('.cell-front').textContent = ''; cell.classList.remove('filled'); } }
        function renderAllRevealedHints() { const revealed = gameData.revealedHints[gameData.currentWordIndex].text || []; revealed.forEach(hintIndex => { const wordObject = wordData[gameData.hourlySet[gameData.currentWordIndex]]; if (wordObject.hints && wordObject.hints[hintIndex]) { const p = document.createElement('p'); p.innerHTML = `<strong>${hintIndex + 1}. seg√≠ts√©g:</strong> ${wordObject.hints[hintIndex]}`; p.dataset.hintId = hintIndex; hintDisplayArea.appendChild(p); } }); }
        function showEndMessage() { const wordObject = wordData[gameData.hourlySet[gameData.currentWordIndex]]; const progress = gameData.progress[gameData.currentWordIndex]; let message = gameEndMessageEl.innerHTML; if (progress.status === 'solved' && !progress.scored) { message = `üéâ √úgyes! A helyes sz√≥: <strong>${wordObject.word}</strong>. üéâ`; } else if (progress.status === 'failed') { message = `Sajnos nem siker√ºlt. A megold√°s: <strong>${wordObject.word}</strong>.`; } gameEndMessageEl.innerHTML = message; }
        function flipRow(guess, targetWord) { const targetLetters = targetWord.split(''); const guessLetters = guess.split(''); const letterStates = Array(targetWord.length).fill('absent'); const usedTargetIndexes = new Set(); guessLetters.forEach((letter, index) => { if (letter === targetLetters[index]) { letterStates[index] = 'correct'; usedTargetIndexes.add(index); }}); guessLetters.forEach((letter, index) => { if (letterStates[index] !== 'correct') { const presentIndex = targetLetters.findIndex((l, i) => l === letter && !usedTargetIndexes.has(i)); if (presentIndex !== -1) { letterStates[index] = 'present'; usedTargetIndexes.add(presentIndex); } } }); const rowEl = document.getElementById(`row-${gameData.currentRow}`); for (let i = 0; i < targetWord.length; i++) { const cell = rowEl.children[i]; setTimeout(() => { cell.querySelector('.cell-back').textContent = guessLetters[i]; cell.querySelector('.cell-back').classList.add(letterStates[i]); cell.classList.add('flip'); updateKeyboard(guessLetters[i], letterStates[i]); }, i * 200); } }
        function updateKeyboard(letter, state) { const key = document.querySelector(`.key[data-key="${letter}"]`); if (!key) return; const priorities = { 'correct': 3, 'present': 2, 'absent': 1 }; const currentClass = key.classList.contains('correct') ? 'correct' : key.classList.contains('present') ? 'present' : 'absent'; if (!currentClass || priorities[state] > (priorities[currentClass] || 0)) { key.classList.remove('correct', 'present', 'absent'); key.classList.add(state); } }
        function checkForNewHour() { if (newSetOverlay.classList.contains('visible')) return; const currentSeed = getCurrentHourSeed(); if (gameData.seed && currentSeed !== gameData.seed) { newSetOverlay.classList.add('visible'); } }
        function updateTextHintButtonLabel() { if (!gameData.revealedHints || !gameData.revealedHints[gameData.currentWordIndex]) return; const hintsData = gameData.revealedHints[gameData.currentWordIndex]; const remaining = 3 - (hintsData.textUsedCount || 0); requestTextHintButton.textContent = `Sz√∂veges seg√≠ts√©g (${remaining})`; }
        requestTextHintButton.addEventListener('click', () => { const cost = handleHintCost(); if(spendPointsForHint(cost)) { const hintsData = gameData.revealedHints[gameData.currentWordIndex]; const wordHints = wordData[gameData.hourlySet[gameData.currentWordIndex]].hints; if (hintsData.textUsedCount >= 3) return; const nextHintIndex = hintsData.text.length; if(wordHints && wordHints[nextHintIndex]) { showHintAlert(() => revealTextHint(nextHintIndex)); } } });
        requestLetterHintButton.addEventListener('click', () => { const cost = handleHintCost(); if(spendPointsForHint(cost)) { showHintAlert(revealRandomLetter); } });
        function checkForBonusGameUnlock() { const allSolved = gameData.progress.every(p => p.status === 'solved'); if (allSolved && !gameData.bonusPlayed) { unlockBonusButton.disabled = false; unlockBonusButton.style.cursor = 'pointer'; unlockBonusButton.style.opacity = '1'; unlockBonusButton.classList.add('pulse'); } else { unlockBonusButton.disabled = true; unlockBonusButton.style.cursor = 'not-allowed'; unlockBonusButton.style.opacity = '0.5'; unlockBonusButton.classList.remove('pulse'); } }
        function seededRandom(seed) { let x = Math.sin(seed) * 10000; return x - Math.floor(x); }
        function getCurrentHourSeed() { const now = new Date(); return now.getFullYear() * 1000000 + (now.getMonth() + 1) * 10000 + now.getDate() * 100 + now.getHours(); }
        function handleStartTimerClick() { if (gameData.isGameOver) return; startTimerButton.disabled = true; startTimerButton.style.display = 'none'; keyboardContainer.classList.remove('disabled'); const hintsData = gameData.revealedHints[gameData.currentWordIndex]; requestTextHintButton.disabled = hintsData.textUsedCount >= 3; requestLetterHintButton.disabled = false; gameData.isTimerRunning[gameData.currentWordIndex] = true; saveGame(); }
        
        startTimerButton.addEventListener('click', () => {
             startTimer(gameData.timers[gameData.currentWordIndex]);
             handleStartTimerClick();
        });
        document.addEventListener('keydown', (e) => { if (document.querySelector('.overlay.visible') || ['INPUT', 'TEXTAREA','BUTTON'].includes(document.activeElement.tagName)) return; let key = e.key.toUpperCase(); if (e.code === 'Backspace') key = 'Backspace'; if (e.code === 'Enter') key = 'Enter'; const allKeys = KEY_LAYOUT.flat().map(k => k.toUpperCase()); if (allKeys.includes(key)) { e.preventDefault(); handleKeyPress(key); const keyElement = document.querySelector(`.key[data-key='${key}']`); if (keyElement) { keyElement.classList.add('active-press'); setTimeout(() => keyElement.classList.remove('active-press'), 150); } } });
        refreshButton.addEventListener('click', () => location.reload());
        unlockBonusButton.addEventListener('click', initWheelGame);
        spinButton.addEventListener('click', handleSpinClick);
        solveButton.addEventListener('click', solve);
        buyVowelButton.addEventListener('click', () => { const letter = prompt("Melyik mag√°nhangz√≥t veszed meg 250 pont√©rt?"); if(letter && VOWELS.includes(letter.toUpperCase())) { guessLetter(letter); } else { alert("√ârv√©nytelen mag√°nhangz√≥."); } });
        closeWheelButton.addEventListener('click', () => wheelGameOverlay.classList.remove('visible'));
        
        createWheel();
        initGame();
        setInterval(checkForNewHour, 10000);
    });
    </script>
</body>
</html>
